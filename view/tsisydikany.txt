const db = require('../database/db');
const forge = require('node-forge');
const bcrypt = require('bcrypt');

class MessageModel {
    static async sendMessage(expediteur, destinataire, message) {
        try {
            // üîπ R√©cup√©ration des cl√©s publiques des deux utilisateurs
            const rows = await new Promise((resolve, reject) => {
                db.query(`
                    SELECT id_utilisateur, cle_publique FROM utilisateurs 
                    WHERE id_utilisateur IN (?, ?)`, 
                    [expediteur, destinataire],
                    (error, results) => {
                        if (error) return reject(error);  // Si erreur, rejeter la promesse
                        resolve(results);  // R√©soudre la promesse avec les r√©sultats
                    }
                );
            });
    
            console.log("R√©sultat de la requ√™te SQL:", rows);  // Affiche ce que retourne la requ√™te
    
            // V√©rification si rows est un tableau et contient bien les deux utilisateurs
            if (!Array.isArray(rows) || rows.length < 2) {
                throw new Error('Les deux utilisateurs (exp√©diteur et destinataire) doivent √™tre pr√©sents dans la base de donn√©es.');
            }
    
            let clePubliqueExpediteur, clePubliqueDestinataire;
    
            // Assurez-vous que les cl√©s sont r√©cup√©r√©es correctement
            rows.forEach(user => {
                if (user.id_utilisateur === expediteur) {
                    clePubliqueExpediteur = forge.pki.publicKeyFromPem(user.cle_publique);
                }
                if (user.id_utilisateur === destinataire) {
                    clePubliqueDestinataire = forge.pki.publicKeyFromPem(user.cle_publique);
                }
            });
    
            // V√©rification si les cl√©s publiques ont √©t√© r√©cup√©r√©es
            if (!clePubliqueExpediteur || !clePubliqueDestinataire) {
                throw new Error("Impossible de r√©cup√©rer les cl√©s publiques des utilisateurs.");
            }
    
            // üîπ Chiffrement du message pour l'exp√©diteur et le destinataire
            const messageChiffreExpediteur = forge.util.encode64(clePubliqueExpediteur.encrypt(message));
            const messageChiffreDestinataire = forge.util.encode64(clePubliqueDestinataire.encrypt(message));
    
            // üîπ Sauvegarde du message chiffr√©
            await new Promise((resolve, reject) => {
                db.query(`
                    INSERT INTO messages (expediteur, destinataire, message_chiffre_expediteur, message_chiffre_destinataire) 
                    VALUES (?, ?, ?, ?)`,
                    [expediteur, destinataire, messageChiffreExpediteur, messageChiffreDestinataire],
                    (error, results) => {
                        if (error) return reject(error);  // Si erreur, rejeter la promesse
                        resolve(results);  // R√©soudre la promesse avec les r√©sultats
                    }
                );
            });
    
            return { message: 'Message envoy√© avec succ√®s' };
        } catch (error) {
            console.error("Erreur lors de l'envoi du message:", error.message);
            throw error;
        }
    }

    static async decryptSentMessage(expediteur, messageId, motDePasse) {
        try {
            const rows = await new Promise((resolve, reject) => {
                db.query(`
                    SELECT message_chiffre_expediteur, cle_privee_chiffree, mot_de_passe 
                    FROM messages
                    INNER JOIN utilisateurs ON messages.expediteur = utilisateurs.id_utilisateur
                    WHERE id_message = ? AND expediteur = ?`,
                    [messageId, expediteur],
                    (error, results) => {
                        if (error) return reject(error);
                        resolve(results);
                    }
                );
            });

            if (rows.length === 0) {
                throw new Error('Message non trouv√© ou acc√®s non autoris√©');
            }

            const { message_chiffre_expediteur, cle_privee_chiffree, mot_de_passe } = rows[0];

            // üîπ V√©rification du mot de passe
            const passwordMatch = await bcrypt.compare(motDePasse, mot_de_passe);  // Comparaison avec le mot de passe hach√© dans la base de donn√©es
            if (!passwordMatch) throw new Error('Mot de passe incorrect');

            // üîπ D√©chiffrement de la cl√© priv√©e (simul√©)
            const privateKeyPem = forge.pki.privateKeyFromPem(cle_privee_chiffree);
            const messageDechiffre = privateKeyPem.decrypt(forge.util.decode64(message_chiffre_expediteur));

            return { message: messageDechiffre };
        } catch (error) {
            throw error;
        }
    }
    static async getReceivedMessages(userId) {
        try {
            const rows = await new Promise((resolve, reject) => {
                db.query(`
                    SELECT messages.id_message, messages.expediteur, messages.message_chiffre_destinataire, utilisateurs.cle_privee_chiffree
                    FROM messages
                    INNER JOIN utilisateurs ON messages.destinataire = utilisateurs.id_utilisateur
                    WHERE messages.destinataire = ?`, 
                    [userId],
                    (error, results) => {
                        if (error) return reject(error);
                        resolve(results);
                    }
                );
            });
            return rows;
        } catch (error) {
            throw error;
        }
    }
    
    static async decryptReceivedMessage(destinataire, messageId, motDePasse) {
        try {
            const rows = await new Promise((resolve, reject) => {
                db.query(`
                    SELECT messages.message_chiffre_destinataire, utilisateurs.cle_privee_chiffree, utilisateurs.mot_de_passe
                    FROM messages
                    INNER JOIN utilisateurs ON messages.destinataire = utilisateurs.id_utilisateur
                    WHERE messages.id_message = ? AND messages.destinataire = ?`,
                    [messageId, destinataire],
                    (error, results) => {
                        if (error) return reject(error);
                        resolve(results);
                    }
                );
            });
    
            if (rows.length === 0) {
                throw new Error('Message non trouv√© ou acc√®s non autoris√©');
            }
    
            const { message_chiffre_destinataire, cle_privee_chiffree, mot_de_passe } = rows[0];
    
            // V√©rification du mot de passe du destinataire
            const passwordMatch = await bcrypt.compare(motDePasse, mot_de_passe);
            if (!passwordMatch) throw new Error('Mot de passe incorrect');
    
            // D√©chiffrement de la cl√© priv√©e du destinataire
            const privateKeyPem = forge.pki.privateKeyFromPem(cle_privee_chiffree);
            const messageDechiffre = privateKeyPem.decrypt(forge.util.decode64(message_chiffre_destinataire));
    
            console.log("Message d√©chiffr√© :", messageDechiffre);  // Ajoute un log pour v√©rifier le message d√©chiffr√©
    
            return { message: messageDechiffre };
        } catch (error) {
            console.error("Erreur lors du d√©chiffrement du message du destinataire:", error.message);
            throw error;
        }
    }
    
    
    
    
}

module.exports = MessageModel;







const express = require('express');
const router = express.Router();
const MessageModel = require('../src/model/messageModel');


// üîπ Envoyer un message chiffr√©
router.post('/send', async (req, res) => {
    try {
        const { expediteur, destinataire, message } = req.body;
        console.log(req.body);
        if (!expediteur || !destinataire || !message) {
            return res.status(400).json({ error: "Tous les champs sont requis." });
        }

        const response = await MessageModel.sendMessage(expediteur, destinataire, message);
        res.json(response);  // R√©pondre avec la r√©ponse du mod√®le
    } catch (error) {
        console.error("Erreur lors de l'envoi du message:", error);
        res.status(500).json({ error: error.message });
    }
});

// üîπ R√©cup√©rer les messages re√ßus
router.get('/received/:userId', async (req, res) => {
    try {
        const { userId } = req.params;
        const password = req.headers['password'];  // R√©cup√©rer le mot de passe depuis les en-t√™tes

        if (!password) {
            return res.status(400).json({ error: 'Mot de passe manquant dans les en-t√™tes' });
        }

        const messages = await MessageModel.getReceivedMessages(userId);

        // üîπ D√©chiffrement des messages avant envoi
        const decryptedMessages = await Promise.all(messages.map(async (msg) => {
            if (msg.message_chiffre_destinataire) {
                try {
                    const decryptedMessage = await MessageModel.decryptReceivedMessage(userId, msg.id_message, password);
                    msg.message_dechiffre = decryptedMessage.message; // Ajoute le message d√©chiffr√© √† la r√©ponse
                    return msg;
                } catch (error) {
                    console.error("‚ùå Erreur de d√©chiffrement du message :", error.message);
                    return msg; // M√™me si l'erreur de d√©chiffrement se produit, on renvoie quand m√™me le message chiffr√©
                }
            }
            return msg;
        }));

        // üîπ Envoi des messages d√©chiffr√©s ou chiffr√©s selon le cas
        res.json(decryptedMessages);  // R√©ponse envoy√©e une seule fois ici

    } catch (error) {
        console.error("‚ùå Erreur API /received :", error);
        if (!res.headersSent) {  // V√©rification que la r√©ponse n'a pas √©t√© envoy√©e
            res.status(500).json({ error: error.message });
        }
    }
});




router.post('/received/decrypt/:userId', async (req, res) => {
    try {
        const { userId } = req.params;
        const { messageId, motDePasse } = req.body;

        // V√©rification que le mot de passe et le messageId sont fournis
        if (!messageId || !motDePasse) {
            return res.status(400).json({ error: "Le mot de passe et l'ID du message sont requis." });
        }

        // Appel du mod√®le pour d√©chiffrer le message re√ßu
        const response = await MessageModel.decryptReceivedMessage(userId, messageId, motDePasse);

        // Retourner la r√©ponse d√©chiffr√©e
        res.json(response);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});
// üîπ D√©chiffrer un message envoy√©
router.post('/decryptSent', async (req, res) => {
    try {
        const { expediteur, messageId, motDePasse } = req.body;
        if (!expediteur || !messageId || !motDePasse) {
            return res.status(400).json({ error: "Tous les champs sont requis." });
        }

        const response = await MessageModel.decryptSentMessage(expediteur, messageId, motDePasse);
        res.json(response);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});
// üîπ R√©cup√©rer et d√©chiffrer les messages re√ßus ou envoy√©s




module.exports = router;
<!--<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Messagerie S√©curis√©e & Profil Utilisateur</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
        }
        .container {
            width: 300px;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            text-align: center;
            margin-top: 20px;
        }
        #messages {
            border: 1px solid #ccc;
            padding: 10px;
            height: 300px;
            overflow-y: scroll;
            width: 100%;
            background: #fff;
            text-align: left;
        }
        .logout-btn {
            margin-top: 20px;
            padding: 10px;
            width: 100%;
            background-color: #d9534f;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .logout-btn:hover { background-color: #c9302c; }
        input, button { margin: 5px 0; padding: 10px; width: 100%; }
        .message {
            margin: 5px;
            padding: 10px;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .sent {
            background-color: #e3f2fd;
        }
        .received {
            background-color: #f1f8e9;
        }
        .decrypt-button {
            margin-top: 5px;
            padding: 5px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .decrypt-button:hover { background-color: #0056b3; }
    </style>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
</head>
<body>
    <div class="container">
        <h2>Profil Utilisateur</h2>
        <div class="profile-info">
            <p><strong>Nom:</strong> <span id="userName">Chargement...</span></p>
            <p><strong>Email:</strong> <span id="userEmail">Chargement...</span></p>
            <p><strong>ID:</strong> <span id="userId">Chargement...</span></p>
        </div>
        <button class="logout-btn" onclick="logout()">Se d√©connecter</button>
    </div>

    <div class="container" id="messagerieSection" style="display: none;">
        <h2>Messagerie S√©curis√©e</h2>
        <input type="text" id="destinataireInput" placeholder="ID du destinataire">
        <div id="messages">Chargement des messages...</div>
        <input type="text" id="messageInput" placeholder="√âcrivez un message...">
        <button onclick="sendMessage()">Envoyer</button>
    </div>

    <script>
        const ws = new WebSocket('ws://localhost:3000');
        let userId = null;

        $(document).ready(function() {
            const token = localStorage.getItem('token');
            if (!token) { window.location.href = '/login'; return; }

            $.ajax({
                url: 'http://localhost:3000/api/profil',
                method: 'GET',
                headers: { 'Authorization': 'Bearer ' + token },
                success: function(data) {
                    $('#userName').text(data.nom);
                    $('#userEmail').text(data.email);
                    $('#userId').text(data.id);
                    userId = data.id;
                    $('#messagerieSection').show();
                    fetchMessages();
                },
                error: function() { logout(); }
            });
        });

        ws.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                if (data.destinataire === userId || data.expediteur === userId) {
                    displayMessage(data.message, data.expediteur === userId ? 'Moi' : `Utilisateur ${data.expediteur}`);
                }
            } catch (error) {
                console.error("Erreur WebSocket:", error);
            }
        };

        function displayMessage(message, sender, date) {
    const messagesBox = document.getElementById("messages");
    const messageElement = document.createElement("div");
    messageElement.classList.add("message");

    // V√©rifiez si le message est re√ßu ou envoy√©
    if (sender === "Moi") {
        messageElement.classList.add("sent"); // Classe pour les messages envoy√©s
    } else {
        messageElement.classList.add("received"); // Classe pour les messages re√ßus
    }

    // Formatage de la date
    const formattedDate = new Date(date).toLocaleString([], { hour: '2-digit', minute: '2-digit', hour12: false });

    messageElement.innerHTML = `
        <p>${sender}: ${message}</p>
        <span class="timestamp">${formattedDate}</span>
    `;

    messagesBox.appendChild(messageElement);
    messagesBox.scrollTop = messagesBox.scrollHeight;
}

function fetchMessages() {
    const password = sessionStorage.getItem('userPassword'); 
    const token = localStorage.getItem('token');
    
    if (!password) {
        console.error('üîë Le mot de passe est manquant dans sessionStorage.');
        alert('Le mot de passe est introuvable. Veuillez vous reconnecter.');
        return;
    }

    if (!token) {
        console.error('üîê Le token d\'authentification est manquant.');
        alert('Vous devez √™tre connect√© pour voir vos messages.');
        return;
    }

    if (!userId) {
        console.error('‚ùå userId est introuvable.');
        alert('Probl√®me d\'identification utilisateur. Veuillez vous reconnecter.');
        return;
    }

    $.ajax({
        url: `http://localhost:3000/api/messages/${userId}`,
        method: "GET",
        headers: {
            'Authorization': `Bearer ${token}`,
            'Password': password
        },
        success: function(response) {
            
            console.log("üì© Messages re√ßus et envoy√©s :", response);

            if (!response || response.length === 0) {
                console.warn("‚ö†Ô∏è Aucune donn√©e de message re√ßue.");
                displayMessage("Aucun message trouv√©.", "Syst√®me", new Date());
                return;
            }

            response.forEach(msg => {
                // V√©rifiez si le message a un exp√©diteur ou un destinataire
                const sender = msg.expediteur ? `Utilisateur ${msg.expediteur}` : "Moi";
                const message = msg.message_dechiffre ? msg.message_dechiffre : "üîí Message chiffr√©";
                displayMessage(message, sender, msg.date_envoi);
            });
        },
        error: function(xhr, status, error) {
            console.error("‚ùå Erreur AJAX :", error);
            console.error("üìú R√©ponse du serveur :", xhr.responseText);

            let errorMessage = "Erreur inconnue.";
            if (xhr.status === 401) {
                errorMessage = "‚õî Acc√®s non autoris√©. Veuillez vous reconnecter.";
            } else if (xhr.status === 404) {
                errorMessage = "üì≠ Aucun message trouv√©.";
            } else if (xhr.status === 500) {
                errorMessage = "üí• Erreur interne du serveur. R√©essayez plus tard.";
            }

            alert(errorMessage);
        }
    });
}

        function sendMessage() {
            const message = $('#messageInput').val().trim();
            const destinataire = $('#destinataireInput').val().trim();
            if (!message || !destinataire) { alert("Message et destinataire requis."); return; }

            const data = { expediteur: userId, destinataire: parseInt(destinataire), message };
            $.ajax({
                url: "http://localhost:3000/api/send",
                method: "POST",
                contentType: "application/json",
                headers: { 'Authorization': 'Bearer ' + localStorage.getItem('token') },
                data: JSON.stringify(data),
                success: function() {
                    displayMessage(message, "Moi");
                    ws.send(JSON.stringify(data));
                    $('#messageInput').val("");
                },
                error: function() { alert("Erreur d'envoi."); }
            });
        }

        function logout() {
            localStorage.removeItem('token');
            window.location.href = '/login';
        }
    </script>
</body>
</html>-->
